// Template for a Weathermap NODE, now only containing position information.
const NODE_TEMPLATE = "NODE {id}\n\tPOSITION {x} {y}";

// Template for a Weathermap LINK, now including DEVICE and INTERFACE details.
const LINK_TEMPLATE = "LINK {id1}-{id2}\n\tDEVICE {hostname} {ip}\n\tINTERFACE {interface}\n\tNODES {id1} {id2}";

// The complete base template for the .conf file, matching the new required format.
const CONFIG_TEMPLATE = `
# Automatically generated by AutoCacti Map Creator

BACKGROUND images/backgrounds/%name%.png
WIDTH %width%
HEIGHT %height%
TITLE %name%

KEYTEXTCOLOR 0 0 0
KEYOUTLINECOLOR 0 0 0
KEYBGCOLOR 255 255 255
TITLECOLOR 0 0 0
TIMECOLOR 0 0 0
SCALE DEFAULT 0  0   192 192 192
SCALE DEFAULT 0  1   255 255 255
SCALE DEFAULT 1  10  140 0 255
SCALE DEFAULT 10 25  32 32 255
SCALE DEFAULT 25 40  0 192 255
SCALE DEFAULT 40 55  0 240 0
SCALE DEFAULT 55 70  240 240 0
SCALE DEFAULT 70 85  255 192 0
SCALE DEFAULT 85 100 255 0 0

SET key_hidezero_DEFAULT 1

# End of global section

# TEMPLATE-only NODEs:
# TEMPLATE-only LINKs:
LINK DEFAULT
    WIDTH 3
    BWLABEL bits
    BANDWIDTH 10000M

# regular NODEs:
%nodes%

# regular LINKs:
%links%

# That's All Folks!
`;

/**
 * Generates the content for a Cacti Weathermap .conf file in the new format.
 * @param {Array} nodes - The array of nodes from React Flow.
 * @param {Array} edges - The array of edges from React Flow.
 * @param {string} mapName - The name for the map.
 * @returns {string} The full content of the .conf file.
 */
export function generateCactiConfig(nodes, edges, mapName) {
  const nodeStrings = [];
  const linkStrings = [];

  // A map to hold details of each node, keyed by their ID (IP address).
  const nodeInfoMap = new Map(nodes.map(node => [node.id, node]));
  
  // A map to translate our application node IDs (IPs) to unique Cacti NODE IDs.
  const cactiNodeIdMap = new Map();
  let nodeCounter = 1;

  // First, create all NODE entries and map their IDs.
  for (const node of nodes) {
    const cactiNodeId = `node${String(nodeCounter++).padStart(5, '0')}`;
    cactiNodeIdMap.set(node.id, cactiNodeId);

    nodeStrings.push(
      NODE_TEMPLATE.replace('{id}', cactiNodeId)
        .replace('{x}', Math.round(node.position.x))
        .replace('{y}', Math.round(node.position.y))
    );
  }

  // Next, create all LINK entries using the mapped Cacti NODE IDs.
  for (const edge of edges) {
    const sourceNodeInfo = nodeInfoMap.get(edge.source);
    const targetNodeInfo = nodeInfoMap.get(edge.target);

    if (!sourceNodeInfo || !targetNodeInfo) {
      continue;
    }

    const sourceCactiId = cactiNodeIdMap.get(edge.source);
    const targetCactiId = cactiNodeIdMap.get(edge.target);
    const interfaceName = edge.data?.interface || 'unknown';

    const populatedLink = LINK_TEMPLATE
      .replace(/{id1}/g, sourceCactiId)
      .replace(/{id2}/g, targetCactiId)
      .replace('{hostname}', sourceNodeInfo.data.hostname)
      .replace('{ip}', sourceNodeInfo.data.ip)
      .replace('{interface}', interfaceName);

    linkStrings.push(populatedLink);
  }
  
  // Calculate map dimensions based on node positions
  const allX = nodes.map(n => n.position.x);
  const allY = nodes.map(n => n.position.y);
  const mapWidth = nodes.length > 0 ? Math.round(Math.max(...allX) + 150) : 800;
  const mapHeight = nodes.length > 0 ? Math.round(Math.max(...allY) + 150) : 600;

  // Populate the final configuration template
  let finalConfig = CONFIG_TEMPLATE;
  finalConfig = finalConfig.replace(/%name%/g, mapName);
  finalConfig = finalConfig.replace('%width%', mapWidth);
  finalConfig = finalConfig.replace('%height%', mapHeight);
  finalConfig = finalConfig.replace('%nodes%', nodeStrings.join('\n\n'));
  finalConfig = finalConfig.replace('%links%', linkStrings.join('\n\n'));

  return finalConfig.trim();
}