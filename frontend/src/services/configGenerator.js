// frontend/src/services/configGenerator.js
import { NODE_WIDTH, NODE_HEIGHT } from '../config/constants';

// Template for a Weathermap NODE representing a device with an icon and label.
const DEVICE_NODE_TEMPLATE = "NODE {id}\n\tLABEL {hostname}\n\tICON images/devices/{iconFilename}\n\tPOSITION {x} {y}";

// Template for a Weathermap NODE used as an invisible anchor for a LINK.
const DUMMY_NODE_TEMPLATE = "NODE {id}\n\tPOSITION {x} {y}";

// Template for a Weathermap LINK, connecting two (dummy) nodes and specifying the data source.
const LINK_TEMPLATE = "LINK {id1}-{id2}\n\tDEVICE {hostname} {ip}\n\tINTERFACE {interface}\n\tNODES {id1} {id2}";

// The complete base template for the .conf file.
const CONFIG_TEMPLATE = `
# Automatically generated by AutoCacti Map Creator

BACKGROUND images/backgrounds/%name%.png
WIDTH %width%
HEIGHT %height%
TITLE %name%

KEYTEXTCOLOR 0 0 0
KEYOUTLINECOLOR 0 0 0
KEYBGCOLOR 255 255 255
TITLECOLOR 0 0 0
TIMECOLOR 0 0 0
SCALE DEFAULT 0  0   192 192 192
SCALE DEFAULT 0  1   255 255 255
SCALE DEFAULT 1  10  140 0 255
SCALE DEFAULT 10 25  32 32 255
SCALE DEFAULT 25 40  0 192 255
SCALE DEFAULT 40 55  0 240 0
SCALE DEFAULT 55 70  240 240 0
SCALE DEFAULT 70 85  255 192 0
SCALE DEFAULT 85 100 255 0 0

SET key_hidezero_DEFAULT 1

# End of global section

# TEMPLATE-only NODEs:
# TEMPLATE-only LINKs:
LINK DEFAULT
    WIDTH 3
    BWLABEL bits
    BANDWIDTH 10000M

# regular NODEs:
%nodes%

# regular LINKs:
%links%

# That's All Folks!
`;

/**
 * Generates the content for a Cacti Weathermap .conf file.
 * @param {object} params - The parameters for config generation.
 * @returns {string} The full content of the .conf file.
 */
export function generateCactiConfig({ nodes, edges, mapName, mapWidth, mapHeight, offsetX, offsetY, padding }) {
  const deviceNodes = nodes.filter(node => node.type !== 'group');
  const nodeStrings = [];
  const linkStrings = [];

  const nodeInfoMap = new Map(deviceNodes.map(node => [node.id, node]));
  let nodeCounter = 1;

  // Function to convert absolute map coordinates to coordinates relative to the exported image
  const toRelativePosition = (absolutePos) => {
      return {
          x: absolutePos.x - offsetX + padding,
          y: absolutePos.y - offsetY + padding,
      };
  };

  for (const node of deviceNodes) {
    const cactiNodeId = `node${String(nodeCounter++).padStart(5, '0')}`;
    
    const iconType = node.data.iconType || 'Router';
    let iconFilename;
    switch (iconType) {
        case 'Switch': iconFilename = 'switch-black.png'; break;
        case 'Firewall': iconFilename = 'firewall.png'; break;
        case 'Encryptor': iconFilename = 'encryptor.png'; break;
        case 'Router': default: iconFilename = 'router-black.png'; break;
    }
    
    // Convert absolute node positions to relative positions for the config file.
    // The position in the config corresponds to the center of the node's bounding box.
    const relativePos = toRelativePosition(node.position);
    const centerX = Math.round(relativePos.x + (NODE_WIDTH / 2));
    const centerY = Math.round(relativePos.y + (NODE_HEIGHT / 2));

    nodeStrings.push(
      DEVICE_NODE_TEMPLATE.replace('{id}', cactiNodeId)
        .replace('{hostname}', node.data.hostname)
        .replace('{iconFilename}', iconFilename)
        .replace('{x}', centerX)
        .replace('{y}', centerY)
    );
  }

  // The offset for link endpoints from the node's center. This is based on
  // half the content width of the node (150px), not the total bounding box width.
  const LINK_ENDPOINT_OFFSET = 75; 

  for (const edge of edges) {
    const sourceNodeInfo = nodeInfoMap.get(edge.source);
    const targetNodeInfo = nodeInfoMap.get(edge.target);

    if (!sourceNodeInfo || !targetNodeInfo) continue;
    
    // Use relative coordinates for link endpoint calculations, starting from the node's center.
    const relSourcePos = toRelativePosition(sourceNodeInfo.position);
    const relTargetPos = toRelativePosition(targetNodeInfo.position);

    const x1 = relSourcePos.x + (NODE_WIDTH / 2);
    const y1 = relSourcePos.y + (NODE_HEIGHT / 2);
    const x2 = relTargetPos.x + (NODE_WIDTH / 2);
    const y2 = relTargetPos.y + (NODE_HEIGHT / 2);

    const dx = x2 - x1;
    const dy = y2 - y1;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance === 0) continue;

    const ux = dx / distance;
    const uy = dy / distance;

    const dummy1_x = Math.round(x1 + ux * LINK_ENDPOINT_OFFSET);
    const dummy1_y = Math.round(y1 + uy * LINK_ENDPOINT_OFFSET);
    const dummy2_x = Math.round(x2 - ux * LINK_ENDPOINT_OFFSET);
    const dummy2_y = Math.round(y2 - uy * LINK_ENDPOINT_OFFSET);

    const dummy1_id = `node${String(nodeCounter++).padStart(5, '0')}`;
    const dummy2_id = `node${String(nodeCounter++).padStart(5, '0')}`;

    nodeStrings.push(DUMMY_NODE_TEMPLATE.replace('{id}', dummy1_id).replace('{x}', dummy1_x).replace('{y}', dummy1_y));
    nodeStrings.push(DUMMY_NODE_TEMPLATE.replace('{id}', dummy2_id).replace('{x}', dummy2_x).replace('{y}', dummy2_y));
    
    const interfaceName = edge.data?.interface || 'unknown';
    const populatedLink = LINK_TEMPLATE
      .replace(/{id1}/g, dummy1_id)
      .replace(/{id2}/g, dummy2_id)
      .replace('{hostname}', sourceNodeInfo.data.hostname)
      .replace('{ip}', sourceNodeInfo.data.ip)
      .replace('{interface}', interfaceName);

    linkStrings.push(populatedLink);
  }
  
  let finalConfig = CONFIG_TEMPLATE;
  finalConfig = finalConfig.replace(/%name%/g, mapName);
  finalConfig = finalConfig.replace('%width%', mapWidth);
  finalConfig = finalConfig.replace('%height%', mapHeight);
  finalConfig = finalConfig.replace('%nodes%', nodeStrings.join('\n\n'));
  finalConfig = finalConfig.replace('%links%', linkStrings.join('\n\n'));

  return finalConfig.trim();
}