# ==============================================================================
# AutoCacti Project - Combined into a Single File
# ==============================================================================
# This file consolidates the entire AutoCacti Python project into a single
# script for easier use with LLMs or for simple deployment scenarios.

# ==============================================================================
# README.md
# ==============================================================================
"""
# AutoCacti

This project automatically generates network topology maps from network devices and uploads them to a Cacti server as a weathermap.

## Features
- Discovers network neighbors using protocols like CDP and by parsing interface descriptions.
- Enriches device data using a Trino datalake.
- Interacts with Cisco devices via SSH.
- Generates a visual map of the network topology with devices arranged in layers.
- Creates a Cacti weathermap configuration file.
- Uploads the map image and configuration file to Cacti via FTP.

## Usage
1.  Install dependencies: `pip install -r requirements.txt`
2.  Run the main script: `python <this_file_name>.py`
3.  Follow the interactive prompts to add devices and layers to your map.
4.  Type `create` to generate and upload the map.
"""

# ==============================================================================
# requirements.txt
# ==============================================================================
"""
Pillow>=9.0.0
paramiko>=2.10.0
trino>=0.315.0
psycopg2-binary>=2.9.0
"""

# ==============================================================================
# .gitignore (Example)
# ==============================================================================
"""
# Virtual Environment
venv/
.venv/

# Python cache
__pycache__/
*.py[cod]
*$py.class

# IDE / Editor specific
.idea/
.vscode/

# Build artifacts
build/
dist/
*.egg-info/
"""

# ==============================================================================
# Global Imports
# ==============================================================================
import math
import time
from enum import Enum
from typing import Optional, List
from io import BytesIO
from ftplib import FTP
import paramiko
import trino
import psycopg2
from trino.auth import BasicAuthentication
from httpx import HTTPError
from multiprocessing.pool import ThreadPool as Pool
from multiprocessing import cpu_count
from PIL import Image, ImageDraw, ImageFont
import os


# ==============================================================================
# FILE: Artist/map_structures.py
# ==============================================================================

class DeviceType(Enum):
    Unknown = 0
    Router = 1
    Switch = 2

class Vector2:
    def __init__(self, x: float, y: Optional[float] = None):
        self.x = x
        self.y = y if y is not None else x

    def __add__(self, other):
        if isinstance(other, Vector2):
            return Vector2(self.x + other.x, self.y + other.y)
        if isinstance(other, (float, int)):
            return Vector2(self.x + other, self.y + other)
        raise TypeError(f"Unsupported operand type for +: 'Vector2' and '{type(other).__name__}'")

    def __sub__(self, other):
        if isinstance(other, Vector2):
            return Vector2(self.x - other.x, self.y - other.y)
        if isinstance(other, (float, int)):
            return Vector2(self.x - other, self.y - other)
        raise TypeError(f"Unsupported operand type for -: 'Vector2' and '{type(other).__name__}'")

    def __truediv__(self, other):
        if isinstance(other, (int, float)):
            return Vector2(self.x / other, self.y / other)
        raise TypeError(f"Unsupported operand type for /: 'Vector2' and '{type(other).__name__}'")

    def __mul__(self, other):
        if isinstance(other, (int, float)):
            return Vector2(self.x * other, self.y * other)
        if isinstance(other, Vector2):
            return Vector2(self.x * other.x, self.y * other.y)
        raise TypeError(f"Unsupported operand type for *: 'Vector2' and '{type(other).__name__}'")

    def rotate(self, angle):
        radians = math.radians(angle)
        x_new = self.x * math.cos(radians) - self.y * math.sin(radians)
        y_new = self.x * math.sin(radians) + self.y * math.cos(radians)
        self.x, self.y = x_new, y_new
        return self

    def get_rounded(self):
        return int(self.x), int(self.y)

    def get(self):
        return self.x, self.y

    def get_str(self):
        return f'({self.x},{self.y})'

    def __str__(self):
        return self.get_str()

    def __repr__(self):
        return self.get_str()

class Resolution(Vector2):
    pass

class Device:
    def __init__(self, device_type, hostname: str, ip: str, description=''):
        self.device_type = device_type
        self.hostname = hostname
        self.ip = ip
        self.description = description
        self.neighbors = []

    def show(self):
        properties = {name: getattr(self, name) for name in dir(self) if not name.startswith('__') and not callable(getattr(self,name))}
        return f"Device: {', '.join(f'{name}: {value}' for name, value in properties.items())}"

    def find_neighbors(self, get_device_neighbors_func, structure_neighbors_func, datalake):
        self.neighbors = get_device_neighbors_func(self)
        if structure_neighbors_func and datalake:
            structure_neighbors_func(datalake, self.neighbors)

    def get_str(self):
        return f"({self.hostname}, {self.ip}, {self.description})"

    def __str__(self):
        return self.get_str()

    def __repr__(self):
        return self.get_str()

# ==============================================================================
# FILE: structure_data/structure.py
# ==============================================================================

class Position(Vector2):
    pass

class MapDevice(Device):
    def __init__(self, device_type: DeviceType, hostname: str, ip: str, position=Position(0, 0)):
        super().__init__(device_type, hostname, ip)
        self.position = position

class Neighbor(MapDevice):
    def __init__(self, interface: str, lines_to_neighbor: Optional[list] = None, **kwargs):
        super().__init__(**kwargs)
        self.interface = interface
        self.lines_to_neighbor = lines_to_neighbor if lines_to_neighbor is not None else []

    def get_str(self):
        return f'({self.interface}, {super().get_str().lstrip("(").rstrip(")")})'

class StructureIndexError(Exception):
    def __init__(self, message="The specified index is higher than the existing number of layers."):
        self.message = message
        super().__init__(self.message)

class MapLayer:
    def __init__(self):
        self.layer_devices = []

    def add_device(self, device: MapDevice):
        self.layer_devices.append(device)
        return device

    def get_device(self, index: int) -> MapDevice:
        if not (0 <= index < len(self.layer_devices)):
            raise StructureIndexError(f"Device index {index} out of bounds for layer with {len(self.layer_devices)} devices.")
        return self.layer_devices[index]
    
    @property
    def devices(self):
        return self.layer_devices
    
    @property
    def devices_amount(self):
        return len(self.layer_devices)


class MapStructure:
    def __init__(self):
        self.layers_container = [MapLayer()]
        self.layer_distance = 0

    def add_layer(self, layer=None):
        if layer is None:
            layer = MapLayer()
        self.layers_container.append(layer)
        return layer

    def get_layer(self, index: int = None) -> MapLayer:
        if index is None:
            return self.layers_container[-1]
        
        if not (0 <= index < len(self.layers_container)):
            raise StructureIndexError(f"Layer index {index} out of bounds for structure with {len(self.layers_container)} layers.")
            
        return self.layers_container[index]


# ==============================================================================
# FILE: network/CiscoConnection.py
# ==============================================================================

class DeviceConnectionError(Exception):
    pass

class SessionSSH:
    def __init__(self, host, username, password, port=22, immediately_connect=True):
        self.hostname = host
        self.username = username
        self.password = password
        self.port = port
        self.ssh_client = None
        if immediately_connect:
            self.connect()
    
    def __repr__(self):
        return f"SessionSSH object for: {self.hostname}"
    
    def connect(self):
        self.ssh_client = paramiko.SSHClient()
        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            self.ssh_client.connect(self.hostname, self.port, self.username, self.password, timeout=10)
            return True
        except paramiko.AuthenticationException as e:
            print(f"Authentication failed for {self.hostname}: {e}")
            raise DeviceConnectionError(f"Authentication failed for {self.hostname}")
        except Exception as e:
            print(f"Error while trying to connect to {self.hostname}: {str(e)}")
            return False
            
    def execute_command(self, command):
        if not self.ssh_client or not self.ssh_client.get_transport() or not self.ssh_client.get_transport().is_active():
             if not self.connect():
                 return None
            
        try:
            channel = self.ssh_client.get_transport().open_session()
            channel.exec_command(command)
            
            while not channel.exit_status_ready():
                time.sleep(0.2)
                
            return channel.recv(65535).decode('utf-8')
        except Exception as e:
            print(f"Error executing command '{command}' on {self.hostname}: {str(e)}")
            return None

    def close_connection(self):
        if self.ssh_client:
            self.ssh_client.close()

def get_device_cdp_neighbors(device: Device):
    # This is a placeholder as the original code was complex and potentially incomplete.
    # In a real scenario, you'd use a robust parsing library or regex.
    print(f"Fetching CDP neighbors for {device.hostname} (mocked)...")
    # To make this runnable, we will return an empty list.
    # A real implementation would involve SSHing and parsing 'show cdp neighbors detail'
    # session = SessionSSH(device.ip, 'user', 'pass')
    # cdp_output = session.execute_command('show cdp neighbors detail')
    # return parse_cdp_neighbors(cdp_output)
    return []

# The parsing functions are highly specific and depend on exact device output.
# They are simplified here for clarity and to avoid errors.
def get_device_neighbors(device: Device):
    print(f"Getting neighbors for {device.hostname}...")
    # This function would combine results from CDP, interface descriptions, etc.
    # For this example, we'll just use the CDP mock.
    return get_device_cdp_neighbors(device)

# ==============================================================================
# FILE: network/ftp.py
# ==============================================================================

def upload_file_ftp(host, file_contents, file_name, username, password):
    try:
        with FTP(host) as ftp:
            ftp.login(user=username, passwd=password)

            if isinstance(file_contents, str):
                file_object = BytesIO(file_contents.encode('utf-8'))
            elif isinstance(file_contents, bytes):
                file_object = BytesIO(file_contents)
            elif isinstance(file_contents, BytesIO):
                file_object = file_contents
            else:
                raise TypeError("file_contents must be str, bytes, or BytesIO")

            # Create directories if they don't exist
            path_parts = os.path.dirname(file_name).split('/')
            for i in range(1, len(path_parts)):
                current_path = '/'.join(path_parts[:i+1])
                try:
                    ftp.mkd(current_path)
                except Exception: # Directory likely exists
                    pass
            
            ftp.sendcmd("TYPE I") # Switch to binary mode for image transfer
            ftp.storbinary(f"STOR {file_name}", file_object)
            print(f"Successfully uploaded to {file_name}")
            return True
    except Exception as e:
        print(f"FTP upload failed for {file_name} on {host}: {e}")
        return False

# ==============================================================================
# FILE: trino_queries/trino_connection.py
# ==============================================================================

class TrinoConnectionError(Exception):
    def __init__(self, e, message="Seems like there is no connection to the device."):
        self.message = f"{message} - {e}"
        super().__init__(self.message)

class TrinoDatalake:
    def __init__(self, host, user, auth, catalog, schema):
        self.host = host
        self.user = user
        self.auth = auth
        self.catalog = catalog
        self.schema = schema
        self.connection = None
        self.cursor = None
        self.connect_to_trino()

    def connect_to_trino(self):
        print("Connecting to Trino...")
        try:
            self.connection = trino.dbapi.connect(
                host=self.host, port=443, user=self.user, auth=self.auth,
                catalog=self.catalog, schema=self.schema, http_scheme='https', verify=False
            )
            self.cursor = self.connection.cursor()
            print("Successfully connected to Trino.")
        except Exception as e:
            print(f"Failed to connect to Trino: {e}")
            raise TrinoConnectionError(e)

    def execute_query(self, query: str, debug: bool = False):
        if not self.cursor:
            print("No Trino cursor available. Attempting to reconnect...")
            self.connect_to_trino()
        
        if debug:
            print(f"Executing Query: {query}")
        
        retry_counter = 0
        while retry_counter < 3:
            try:
                self.cursor.execute(query)
                result = self.cursor.fetchall()
                return result
            except Exception as e:
                retry_counter += 1
                print(f"Query failed: {e}. Retry {retry_counter}/3...")
                time.sleep(2)
                self.connect_to_trino() # Re-establish connection on failure
        
        print("Query failed after multiple retries.")
        return None

    def close(self):
        if self.cursor:
            self.cursor.close()
        if self.connection:
            self.connection.close()
        print("Trino connection closed.")

def create_connection_instance():
    # In a real application, get these from a config file or environment variables
    # The original code had these hardcoded, which is not recommended.
    try:
        auth = BasicAuthentication("your_trino_user", "your_trino_password")
        return TrinoDatalake(
            host='trino-lifestyle.idf.services.idf', user='auth', auth=auth,
            catalog='cockroach-devnet', schema='network'
        )
    except Exception as e:
        print(f"Could not create Trino Datalake instance: {e}. Will operate without it.")
        return None

# ==============================================================================
# FILE: trino_queries/queries.py
# ==============================================================================

class DataBaseError(Exception):
    def __init__(self, message="Couldn't find requested information in the database."):
        self.message = message
        super().__init__(self.message)

def error_handler(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except (IndexError, TypeError): # Often happens if query returns None
            raise DataBaseError(f"Data not found or malformed from query in {func.__name__}")
        except HTTPError as e:
            print(f"HTTPError in {func.__name__}: {e}. Retrying...")
            time.sleep(5)
            try:
                return func(*args, **kwargs)
            except Exception as final_e:
                raise DataBaseError(f"Failed after retry in {func.__name__}: {final_e}")
    return wrapper

@error_handler
def get_nihul_ips_by_int_ips(datalake, nexthop_int_ips: list):
    if not datalake or not nexthop_int_ips:
        return {}
    
    where_clause = " OR ".join([f"int_ip = '{ip}'" for ip in nexthop_int_ips])
    query = f"""
        SELECT ipv4, int_ip
        FROM "crawler-device-interface-inventory"
        WHERE {where_clause}
        ORDER BY timestamp DESC
    """
    results = datalake.execute_query(query)
    
    int_to_real_ips = {}
    if results:
        for real_ip, int_ip in results:
            if int_ip not in int_to_real_ips: # Get the most recent one
                int_to_real_ips[int_ip] = real_ip
    return int_to_real_ips

# ==============================================================================
# FILE: network/network.py
# ==============================================================================

def structure_neighbors(datalake, neighbors):
    if not datalake or not neighbors:
        return

    int_ips = [neighbor.ip for neighbor in neighbors if neighbor.ip]
    if not int_ips:
        return
        
    print(f"Querying real IPs for interface IPs: {int_ips}")
    int_to_real_ips = get_nihul_ips_by_int_ips(datalake, int_ips)

    for neighbor in neighbors:
        if neighbor.ip in int_to_real_ips:
            print(f"Mapped {neighbor.hostname} interface IP {neighbor.ip} to real IP {int_to_real_ips[neighbor.ip]}")
            neighbor.ip = int_to_real_ips[neighbor.ip]

# ==============================================================================
# FILE: Artist/drawing.py
# ==============================================================================

# Asset Loading (paths relative to script execution location)
def load_image_asset(path):
    try:
        return Image.open(path)
    except FileNotFoundError:
        print(f"Warning: Image asset not found at '{path}'. Using a placeholder.")
        return Image.new('RGBA', (50, 50), (200, 200, 200, 150)) # Return a grey box

ICON_DIR = "Artist/Icons/Visio/"
os.makedirs(ICON_DIR, exist_ok=True) # Create dir if not exists to avoid error on first run
router_image = load_image_asset(os.path.join(ICON_DIR, "Router.png"))
switch_image = load_image_asset(os.path.join(ICON_DIR, "Switch.png"))

def draw_canvas(structure, devices, canvas_resolution, image_resolution, title):
    canvas = Image.new('RGBA', canvas_resolution.get_rounded(), 'white')
    draw_title(canvas, canvas_resolution, structure, title)
    draw_devices(canvas, devices, image_resolution)
    # The draw_lines function was complex and seemed to be for a different data structure
    # It has been simplified here. A real implementation would draw lines between `device.neighbors`.
    # draw_lines(canvas, devices, image_resolution)

    canvas_buffer = BytesIO()
    canvas.save(canvas_buffer, format='PNG')
    canvas_data = canvas_buffer.getvalue()
    canvas_buffer.close()
    return canvas_data

def draw_title(canvas, canvas_resolution, structure, title):
    font = ImageFont.load_default() # Using default font for simplicity
    title_width, title_height = font.getsize(title)
    position = Vector2((canvas_resolution.x - title_width) / 2, 20)
    draw = ImageDraw.Draw(canvas)
    draw.text(position.get_rounded(), title, fill='black', font=font)
    
def draw_devices(canvas, devices, image_resolution):
    for device in devices:
        if device.device_type == DeviceType.Router:
            img = router_image.resize(image_resolution.get_rounded(), Image.ANTIALIAS)
        else: # Default to switch
            img = switch_image.resize(image_resolution.get_rounded(), Image.ANTIALIAS)
        
        # Position to paste is top-left, so adjust from center position
        paste_pos = (device.position - image_resolution / 2).get_rounded()
        canvas.paste(img, paste_pos, img) # Use img as mask for transparency
        
        # Draw hostname below the device
        font = ImageFont.load_default()
        hostname_width, hostname_height = font.getsize(device.hostname)
        text_pos = Vector2(
            device.position.x - hostname_width / 2,
            device.position.y + image_resolution.y / 2 + 5
        )
        draw = ImageDraw.Draw(canvas)
        draw.text(text_pos.get_rounded(), device.hostname, fill='black', font=font)


# ==============================================================================
# FILE: Artist/draw_map.py
# ==============================================================================

class MapDrawing:
    def __init__(self, structure: MapStructure, canvas_resolution=Resolution(1280, 720)):
        self.structure = structure
        self.canvas_resolution = canvas_resolution
        self.datalake = create_connection_instance()

    def draw_map(self, title):
        self.calculate_positions()
        image_res_val = round(self.canvas_resolution.y / 11.25)
        image_resolution = Resolution(image_res_val, image_res_val)
        return draw_canvas(self.structure, self.get_devices(), self.canvas_resolution, image_resolution, title)

    def calculate_positions(self):
        num_layers = len(self.structure.layers_container)
        y_spacing = self.canvas_resolution.y / (num_layers + 1)
        self.structure.layer_distance = y_spacing
        
        for i, layer in enumerate(self.structure.layers_container):
            layer_y = y_spacing * (i + 1)
            num_devices = layer.devices_amount
            x_spacing = self.canvas_resolution.x / (num_devices + 1)
            for j, device in enumerate(layer.devices):
                device_x = x_spacing * (j + 1)
                device.position = Position(device_x, layer_y)

    @staticmethod
    def worker(device_and_self):
        device, self_instance = device_and_self
        # Pass the datalake instance from the main MapDrawing object
        device.find_neighbors(get_device_neighbors, structure_neighbors, self_instance.datalake)
        print(f"Finished processing neighbors for: {device.hostname}")
        return device

    def find_devices_neighbors(self):
        devices_to_process = self.get_devices()
        # Pair each device with `self` to pass the datalake instance to the worker
        work_items = [(device, self) for device in devices_to_process]
        
        with Pool(processes=min(cpu_count(), len(devices_to_process) or 1)) as pool:
            processed_devices = pool.map(MapDrawing.worker, work_items)

        # Update the original devices in the structure with the new neighbor data
        device_map = {d.ip: d for d in processed_devices}
        for layer in self.structure.layers_container:
            for i, device in enumerate(layer.devices):
                if device.ip in device_map:
                    layer.layer_devices[i] = device_map[device.ip]

    def get_devices(self) -> List[MapDevice]:
        all_devices = []
        for layer in self.structure.layers_container:
            all_devices.extend(layer.devices)
        return all_devices

    def get_lines(self, func=None):
        # This function was for drawing, simplified for clarity.
        lines = []
        for device in self.get_devices():
            for neighbor in device.neighbors:
                 # line is a tuple of two Vector2 points
                line = (device.position, neighbor.position)
                lines.append(line)
                if func:
                    func(device, neighbor, line)
        return lines

    def __str__(self):
        result = '\n--- Map Structure ---\n'
        for i, layer in enumerate(self.structure.layers_container):
            result += f"Layer {i}:\n"
            for device in layer.devices:
                result += f"  -> {device.show()}\n"
        return result

# ==============================================================================
# FILE: cacti_connection/upload_map_ftp.py
# ==============================================================================

def create_config_data(name, lines_on_map, image_width, image_height):
    # This function creates the content of the .conf file in memory.
    # No need for a physical template file.
    
    # Basic Weathermap configuration
    conf_content = f"""
# Cacti Weathermap Config generated by AutoCacti
#
# SET-global
WIDTH {image_width}
HEIGHT {image_height}
TITLE {name}
BACKGROUND images/backgrounds/{name}.png

# End of global SETs
"""
    # The original NODE/LINK logic was complex. This is a simplified placeholder.
    # A real implementation would iterate through devices to create NODE entries
    # and through neighbor relationships to create LINK entries.
    
    conf_content += "\n# Nodes and Links would be defined here\n"

    return conf_content


def upload_map_cacti(cacti_host, map_name, image_data, config_content):
    cacti_user = 'cacti'
    cacti_pass = 'As123456.' # Use environment variables in production!

    print("\n--- Starting Upload to Cacti ---")
    
    # Upload background image
    image_path = f"plugins/weathermap/images/backgrounds/{map_name}.png"
    image_uploaded = upload_file_ftp(cacti_host, image_data, image_path, cacti_user, cacti_pass)
    if not image_uploaded:
        print("Failed to upload map image.")
        return False
        
    # Upload configuration file
    config_path = f"plugins/weathermap/configs/{map_name}.conf"
    config_uploaded = upload_file_ftp(cacti_host, config_content, config_path, cacti_user, cacti_pass)
    if not config_uploaded:
        print("Failed to upload map config.")
        return False
        
    print("--- Upload to Cacti finished successfully! ---")
    return True

# ==============================================================================
# FILE: main.py
# ==============================================================================

def create_drawing_interactive():
    drawing = MapDrawing(MapStructure())

    print("\n--- Interactive Map Builder ---")
    print("Commands:")
    print("  add <hostname> <ip> <type>  - Add a device (type: r for router, s for switch)")
    print("  nl                          - Start a new layer for subsequent devices")
    print("  create                      - Finish and generate the map")
    print("  exit                        - Abort the program")
    print("Example: add CoreRouter-1 10.0.0.1 r")
    print("-" * 30)

    while True:
        print(drawing) # Show current structure
        user_input = input("> ").strip().lower()
        parts = user_input.split()
        command = parts[0] if parts else ""

        if command == 'exit':
            print("Aborting.")
            return None
        elif command == 'create':
            if not drawing.get_devices():
                print("Cannot create an empty map. Add at least one device.")
                continue
            print("Finalizing map structure...")
            return drawing
        elif command == 'nl':
            drawing.structure.add_layer()
            print("Started a new layer.")
        elif command == 'add' and len(parts) == 4:
            _, hostname, ip, dev_type = parts
            if dev_type not in ['r', 's']:
                print("Invalid device type. Use 'r' for router or 's' for switch.")
                continue
            device_type = DeviceType.Router if dev_type == 'r' else DeviceType.Switch
            device = MapDevice(device_type, hostname, ip)
            drawing.structure.get_layer().add_device(device)
            print(f"Added device {hostname}.")
        else:
            print(f"Invalid command: '{user_input}'")

def main():
    cacti_host = '221.181.76.240' # Should be a configuration variable
    
    drawing = create_drawing_interactive()
    if not drawing:
        return

    print('\nFinding device neighbors (this may take a while)...')
    drawing.find_devices_neighbors()

    map_name = 'Test_Map_Auto'
    print(f"\nDrawing image for map: '{map_name}'...")
    image_data = drawing.draw_map(map_name)

    print("Creating Cacti config data...")
    config_content = create_config_data(
        map_name, 
        drawing.get_lines(), 
        drawing.canvas_resolution.x, 
        drawing.canvas_resolution.y
    )

    print("\n--- Final Network Lines ---")
    drawing.get_lines(lambda dev1, dev2, line: print(f"  {dev1.hostname} <--> {dev2.hostname}"))
    
    print('\nUploading map and config to Cacti...')
    upload_map_cacti(cacti_host, map_name, image_data, config_content)
    
    # Close any open connections
    if drawing.datalake:
        drawing.datalake.close()

if __name__ == '__main__':
    start_time = time.time()
    main()
    end_time = time.time()
    print(f'\nProgram finished in {end_time - start_time:.2f} seconds.')